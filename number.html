<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D数字のジェネレーティブアート（自動切替）</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 使用するフォントをLato（サンセリフ）に変更 */
        @import url('https://fonts.googleapis.com/css2?family=Lato:wght@700&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            /* 背景を白に変更 */
            background-color: #ffffff;
            color: #000000;
        }
        canvas {
            display: block;
        }
        /* フィルターをcanvas要素に直接適用 */
        #container canvas {
            filter: url("#goo");
        }
    </style>
</head>
<body>
    <!-- Liquid EffectのためのSVGフィルター（パラメーターを調整） -->
    <svg style="display:none">
      <defs>
        <filter id="goo">
          <!-- stdDeviationの値を大きくしてぼかしを強くし、効果範囲を広げる -->
          <feGaussianBlur in="SourceGraphic" stdDeviation="12" result="blur" />
          <!-- feColorMatrixの値を調整して、アルファチャンネルのコントラストをより強くし、境界をくっきりさせる -->
          <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 50 -20" result="goo" />
          <feBlend in="SourceGraphic" in2="goo" />
        </filter>
      </defs>
    </svg>

    <div id="container"></div>

    <!-- three.jsとOrbitControlsの読み込み -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let particles = [];
        let isAnimating = false; // アニメーション中フラグ
        const numParticles = 1500;
        const highlightRadius = 10;

        // パターンの定義
        const patterns = ['sphere', 'torus', 'knot'];
        let currentPatternIndex = 0;
        let currentPattern = patterns[currentPatternIndex];

        const textures = {
            normal: {},
            highlight: {}
        };

        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 0.5;

        // 初期化処理
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha:trueで背景を透過
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0); // レンダラーの背景は透明に
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.2;

            generateAllTextures();
            createInitialParticles();
            addEventListeners();
            
            // 最初のトランジションをスケジュール
            setTimeout(scheduleNextTransition, 4000); // 最初の収束アニメーションが終わるのを待つ

            animate();
        }

        // 通常の数字テクスチャを生成
        function createDigitTexture(digit, textColor) {
            const canvas = document.createElement('canvas');
            const size = 64;
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            // フォントを'Lato'に変更
            context.font = `700 ${size * 0.9}px 'Lato', sans-serif`;
            context.fillStyle = textColor;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(digit, size / 2, size / 2 + size * 0.05);
            return new THREE.CanvasTexture(canvas);
        }

        // 円形背景付きのハイライト用テクスチャを生成
        function createDigitTextureWithCircleBg(digit, textColor, bgColor) {
            const canvas = document.createElement('canvas');
            const size = 64;
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            
            // 円形の背景を描画
            context.fillStyle = bgColor;
            context.beginPath();
            context.arc(size / 2, size / 2, size * 0.48, 0, Math.PI * 2);
            context.fill();

            // テキストを描画
            context.font = `700 ${size * 0.9}px 'Lato', sans-serif`;
            context.fillStyle = textColor;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(digit, size / 2, size / 2 + size * 0.05);
            return new THREE.CanvasTexture(canvas);
        }
        
        // 全テクスチャをキャッシュ
        function generateAllTextures() {
            for (let i = 0; i < 10; i++) {
                // 通常: 黒文字、透明背景
                textures.normal[i] = createDigitTexture(i.toString(), '#000000');
                // ハイライト: 白文字、黒い円形背景
                textures.highlight[i] = createDigitTextureWithCircleBg(i.toString(), '#ffffff', '#000000');
            }
        }

        // パーティクルを生成
        function createInitialParticles() {
            const scatterRadius = 120;
            for (let i = 0; i < numParticles; i++) {
                const digit = Math.floor(Math.random() * 10);
                const sprite = new THREE.Sprite(
                    new THREE.SpriteMaterial({ map: textures.normal[digit], sizeAttenuation: true, depthTest: false, transparent: true })
                );
                sprite.scale.set(2, 2, 1);
                
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.acos((Math.random() * 2) - 1);
                sprite.position.setFromSphericalCoords(scatterRadius, phi, theta);

                sprite.userData = { 
                    digit: digit, 
                    targetPosition: new THREE.Vector3(),
                    isRandomlyHighlighted: Math.random() < 0.05,
                    floatOffset: Math.random() * Math.PI * 2,
                    floatSpeed: 0.5 + Math.random() * 0.5
                };
                particles.push(sprite);
                scene.add(sprite);
            }
            updateTargetPositions();
        }

        // パーティクルの目標位置を計算
        function updateTargetPositions() {
            const scale = 50;
            const knotParams = {
                a: Math.floor(Math.random() * 3) + 2,
                b: Math.floor(Math.random() * 3) + 3,
                c: Math.floor(Math.random() * 3) + 4,
            };

            particles.forEach((p, i) => {
                let x, y, z;
                
                switch (currentPattern) {
                    case 'sphere':
                        const phi = Math.acos(-1 + (2 * i) / numParticles);
                        const theta = Math.sqrt(numParticles * Math.PI) * phi;
                        x = scale * Math.cos(theta) * Math.sin(phi);
                        y = scale * Math.sin(theta) * Math.sin(phi);
                        z = scale * Math.cos(phi);
                        break;
                    case 'torus':
                        const majorRadius = scale * 0.8;
                        const minorRadius = scale * 0.3;
                        const u = (i / numParticles) * Math.PI * 2;
                        const v = (i / numParticles) * Math.PI * 2 * 20;
                        x = (majorRadius + minorRadius * Math.cos(v)) * Math.cos(u);
                        y = (majorRadius + minorRadius * Math.cos(v)) * Math.sin(u);
                        z = minorRadius * Math.sin(v);
                        break;
                    case 'knot':
                        const t_knot = (i / numParticles) * Math.PI * 8;
                        x = scale * Math.sin(knotParams.a * t_knot);
                        y = scale * Math.cos(knotParams.b * t_knot);
                        z = scale * Math.sin(knotParams.c * t_knot);
                        break;
                }
                p.userData.targetPosition.set(x, y, z);
            });
        }

        // イベントリスナーを設定
        function addEventListeners() {
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
        }
        
        // 次のトランジションを予約する
        function scheduleNextTransition() {
            setTimeout(triggerTransition, 5000); // 5秒のアイドルタイム
        }

        // パターン切替のトリガー
        function triggerTransition() {
            if (isAnimating) return;
            isAnimating = true;

            if (currentPatternIndex === patterns.length - 1) {
                currentPatternIndex = 0;
                const nextPattern = patterns[currentPatternIndex];
                const scatterRadius = 120;
                particles.forEach(p => {
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.acos((Math.random() * 2) - 1);
                    p.userData.targetPosition.setFromSphericalCoords(scatterRadius, phi, theta);
                });
                setTimeout(() => {
                    currentPattern = nextPattern;
                    updateTargetPositions();
                }, 1200);
                setTimeout(() => {
                    isAnimating = false;
                    scheduleNextTransition();
                }, 4000);
            } else {
                currentPatternIndex++;
                const nextPattern = patterns[currentPatternIndex];
                currentPattern = nextPattern;
                updateTargetPositions();
                setTimeout(() => {
                    isAnimating = false;
                    scheduleNextTransition();
                }, 3000);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;
            const pulse = 1.0 + Math.sin(time * 2.5) * 0.05;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(particles);
            const intersectedObject = intersects.length > 0 ? intersects[0].object : null;

            particles.forEach(p => {
                p.position.lerp(p.userData.targetPosition, 0.02);

                if (isAnimating) {
                    p.scale.lerp(new THREE.Vector3(2, 2, 1), 0.1);
                } else {
                    const floatStrength = 1.5;
                    const floatTime = time * p.userData.floatSpeed;
                    const floatX = Math.sin(floatTime + p.userData.floatOffset) * floatStrength;
                    const floatY = Math.cos(floatTime + p.userData.floatOffset * 1.2) * floatStrength;
                    const floatZ = Math.sin(floatTime + p.userData.floatOffset * 1.5) * floatStrength;
                    
                    const floatingTarget = new THREE.Vector3().copy(p.userData.targetPosition).add(new THREE.Vector3(floatX, floatY, floatZ));
                    p.position.lerp(floatingTarget, 0.05);

                    let isHoverHighlighted = false;
                    if (intersectedObject) {
                        const distance = p.position.distanceTo(intersectedObject.position);
                        if (distance < highlightRadius) {
                            isHoverHighlighted = true;
                        }
                    }
                    const shouldBeHighlighted = isHoverHighlighted || p.userData.isRandomlyHighlighted;

                    const baseScale = shouldBeHighlighted ? 3 : 2;
                    p.material.map = shouldBeHighlighted ? textures.highlight[p.userData.digit] : textures.normal[p.userData.digit];
                    p.scale.set(baseScale * pulse, baseScale * pulse, 1);
                }
            });

            if (!isAnimating) {
                const zoomTime = time * 0.6;
                camera.fov = 75 + Math.sin(zoomTime) * 25;
                camera.updateProjectionMatrix();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
