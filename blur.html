<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D 跳ねる球体シミュレーション</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: "Inter", sans-serif;
            background-color: #E0E0E0; /* 背景を明るいグレーに設定 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            display: block;
            background-color: #E0E0E0; /* キャンバスの背景も明るいグレーに設定 */
            /* キャンバスが画面全体を覆うように調整 */
            width: 100vw;
            height: 100vh;
            border-radius: 0; /* 角の丸みをなくす */
            box-shadow: none; /* 影をなくす */
        }
        /* #info div は削除されました */
    </style>
</head>
<body>
    <!-- #info div は削除しました -->
    <canvas id="bouncingCanvas"></canvas>

    <script type="module">
        const canvas = document.getElementById('bouncingCanvas');
        const ctx = canvas.getContext('2d');

        // キャンバスのサイズをウィンドウ全体に設定
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // 物理定数
        const gravity = 0.15; // 重力
        const friction = 0.99; // 摩擦 (空気抵抗など)
        const groundFriction = 0.8; // 地面との摩擦
        const velocityThreshold = 0.2; // 静止とみなす速度のしきい値
        const impulseStrength = 10; // 再活性化時の力の基本強さ
        const randomJumpChance = 0.015; // 静止した球体がランダムにジャンプする確率 (毎フレーム)
        const clickImpulseStrength = 20; // クリック時の跳ね返りの強さ

        // 黄金比
        const phi = (1 + Math.sqrt(5)) / 2; // 黄金比 (約 1.618)

        // 画像の配色に合わせたグラデーション用の色の組み合わせ
        const auroraGradientColorSets = [
            // 明るいオレンジ
            ['#FF4500', '#FF6347', '#FF8C00'], // OrangeRed to Tomato to DarkOrange
            // 鮮やかなピンク
            ['#FF1493', '#FF69B4', '#FFB6C1'], // DeepPink to HotPink to LightPink
            // 明るい水色/ターコイズ
            ['#00CED1', '#40E0D0', '#AFEEEE'], // DarkTurquoise to Turquoise to PaleTurquoise
            // 別のオレンジ系
            ['#FF7F50', '#FFA07A', '#FFDAB9'], // Coral to LightSalmon to PeachPuff
            // 別のピンク系
            ['#DB7093', '#FFC0CB', '#F08080'], // PaleVioletRed to Pink to LightCoral
            // 別の水色/ターコイズ系
            ['#20B2AA', '#48D1CC', '#87CEEB'], // LightSeaGreen to MediumTurquoise to SkyBlue
            // 少し落ち着いたオレンジ
            ['#FF8C00', '#FFA500', '#FFD700']  // DarkOrange to Orange to Gold
        ];


        // HexカラーコードをRGBA形式に変換するヘルパー関数
        function hexToRgba(hex, alpha) {
            let r = 0, g = 0, b = 0;
            // #RRGGBB 形式を処理
            if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // 球体オブジェクトの配列
        const spheres = [];
        // プラットフォームオブジェクトの配列
        const platforms = [];
        // 最大質量を追跡するための変数
        let maxSphereMass = 0;

        // Sphere クラスの定義
        class Sphere {
            constructor(x, y, radius, mass, restitution, gradientColorSetIndex) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.mass = mass; // 質量は外部から設定される
                this.restitution = restitution; // 反発係数 (0.0 から 1.0)
                // グラデーションに使う色のセットのインデックス
                this.gradientColorSet = auroraGradientColorSets[gradientColorSetIndex];
                this.vx = (Math.random() - 0.5) * 10; // 初期X方向速度の範囲を縮小
                this.vy = (Math.random() - 0.5) * 10; // 初期Y方向速度の範囲を縮小
            }

            // 球体を描画するメソッド
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                // 円の中心から外側への放射状グラデーションを作成
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, this.radius * 0.1, // 内側の円 (開始点)
                    this.x, this.y, this.radius        // 外側の円 (終了点)
                );

                // グラデーションの色の設定 - 外側に向けてより透明になるように調整
                // 中心は比較的透明度が高く、外側に向かって完全に透明になるように
                gradient.addColorStop(0, hexToRgba(this.gradientColorSet[0], 0.6)); // 中心は少し不透明
                gradient.addColorStop(0.5, hexToRgba(this.gradientColorSet[1], 0.3)); // 中間はより透明
                gradient.addColorStop(1, hexToRgba(this.gradientColorSet[2], 0.0)); // 外側は完全に透明

                ctx.fillStyle = gradient; // グラデーションを塗りつぶしスタイルに設定
                ctx.fill();
                ctx.closePath();
            }

            // 球体の状態を更新するメソッド
            update() {
                // 重力を適用
                this.vy += gravity;

                // 速度を更新
                this.x += this.vx;
                this.y += this.vy;

                // 壁との衝突判定
                // 右の壁
                if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx *= -this.restitution; // 反発
                }
                // 左の壁
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= -this.restitution; // 反発
                }

                // 地面との衝突判定 (キャンバスの底)
                if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.vy *= -this.restitution; // 反発
                    this.vx *= groundFriction; // 地面との摩擦
                    // 速度が非常に小さい場合は停止とみなす
                    if (Math.abs(this.vy) < 0.1) this.vy = 0;
                    if (Math.abs(this.vx) < 0.1) this.vx = 0;
                }
                // 天井との衝突判定
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= -this.restitution; // 反発
                }

                // プラットフォームとの衝突判定
                platforms.forEach(platform => {
                    // 球体の次の位置がプラットフォームのY座標を超えるかどうかをチェック
                    if (this.y + this.radius > platform.y &&
                        this.y + this.radius - this.vy <= platform.y && // 前のフレームではプラットフォームの上にいなかった
                        this.x + this.radius > platform.x &&
                        this.x - this.radius < platform.x + platform.width) {
                        
                        this.y = platform.y - this.radius; // プラットフォームの上に配置
                        this.vy *= -this.restitution; // 反発
                        this.vx *= groundFriction; // プラットフォームとの摩擦
                        if (Math.abs(this.vy) < 0.1) this.vy = 0;
                        if (Math.abs(this.vx) < 0.1) this.vx = 0;
                    }
                });


                // 全体的な摩擦 (空気抵抗)
                this.vx *= friction;
                this.vy *= friction;

                // 静止した球体の再活性化
                if (Math.abs(this.vx) < velocityThreshold && Math.abs(this.vy) < velocityThreshold) {
                    // 再活性化の力を質量に反比例させる
                    const effectiveImpulseStrength = impulseStrength * (maxSphereMass / this.mass);
                    const randomImpulseMultiplier = 0.5 + Math.random() * 1.5; // 0.5から2.0倍の範囲
                    this.vy = -effectiveImpulseStrength * randomImpulseMultiplier; // 上向きにランダムな力を加える
                    this.vx = (Math.random() - 0.5) * effectiveImpulseStrength * randomImpulseMultiplier; // 横方向の力を強化
                }
            }
        }

        // Platform クラスの定義
        class Platform {
            constructor(x, y, width, height, color = 'rgba(0, 0, 0, 0)') { // 地面の色を完全に透明に変更
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }

            // プラットフォームを描画するメソッド (完全に透明なので実質何も描画しない)
            draw() {
                // ctx.fillStyle = this.color; // 描画しない
                // ctx.fillRect(this.x, this.y, this.width, this.height); // 描画しない
            }
        }

        // シミュレーションの初期化
        function initSimulation() {
            const numberOfSpheres = 7; // 球体の数を7に維持
            const minRadius = 120; // 最小半径を120に維持
            const maxRadius = 240; // 最大半径を240に維持

            // Fibonacci sequence for radii
            const fibonacciNumbers = [1, 2, 3, 5, 8, 13, 21]; // 7つの異なるフィボナッチ数
            const fibMinVal = fibonacciNumbers[0]; // 1
            const fibMaxVal = fibonacciNumbers[fibonacciNumbers.length - 1]; // 21

            // Scale factor to map Fibonacci numbers to the desired radius range
            // 半径の範囲にフィボナッチ数をマッピングするためのスケール係数
            const radiusScaleFactor = (maxRadius - minRadius) / (fibMaxVal - fibMinVal);

            // 球体の初期配置範囲を黄金比に基づいて設定
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const initialSpawnWidth = canvas.width / phi; // 黄金比で幅を決定
            const initialSpawnHeight = canvas.height / phi; // 黄金比で高さを決定
            const spawnXStart = centerX - initialSpawnWidth / 2;
            const spawnYStart = centerY - initialSpawnHeight / 2;

            // 最大質量をリセット
            maxSphereMass = 0;

            // グラデーション色のセットをシャッフルしてユニークな色を割り当てる
            let shuffledGradientColorSets = [...auroraGradientColorSets].sort(() => 0.5 - Math.random());
            // フィボナッチ数をシャッフルしてランダムな順序で半径を割り当てる
            let shuffledFibonacciNumbers = [...fibonacciNumbers].sort(() => 0.5 - Math.random());


            for (let i = 0; i < numberOfSpheres; i++) {
                // フィボナッチ数に基づいて半径を計算し、指定された範囲に線形にマッピング
                const fibNum = shuffledFibonacciNumbers[i];
                const radius = minRadius + (fibNum - fibMinVal) * radiusScaleFactor;

                // 質量を半径に比例させつつ、さらにランダムな変動を加える
                const mass = radius * 0.1 * (0.8 + Math.random() * 0.4); // 0.8から1.2倍の範囲で変動
                if (mass > maxSphereMass) {
                    maxSphereMass = mass; // 最大質量を更新
                }

                // 反発係数をより高く、狭い範囲に設定して、より一貫した跳ね返りを実現
                const restitution = 0.95 + Math.random() * 0.04; // 0.95から0.99の間に設定

                // 黄金比で定義された範囲内にランダムに配置
                const x = spawnXStart + Math.random() * initialSpawnWidth;
                const y = spawnYStart + Math.random() * initialSpawnHeight;

                // Sphereコンストラクタにグラデーション色セットのインデックスを渡す
                spheres.push(new Sphere(x, y, radius, mass, restitution, i % shuffledGradientColorSets.length));
            }

            // プラットフォームの追加
            const platformHeight = 20;
            const numPlatforms = 2; // プラットフォームの数を2に維持

            // プラットフォームのY座標を黄金比に基づいて設定 (数が減ったので、より均等に分散)
            const goldenRatioYPositions = [
                canvas.height * (1 / phi),         // 約 0.618 * height
                canvas.height * (1 - 1 / phi)      // 約 0.382 * height (上から)
            ];
            // 重複を避けるため、ユニークな位置を選び、ソート
            const uniqueYPositions = [...new Set(goldenRatioYPositions)].sort((a, b) => a - b);

            for (let i = 0; i < numPlatforms; i++) {
                // プラットフォームの幅をさらに狭く調整 (例: 2%から8%の範囲)
                const platformWidth = canvas.width * (0.02 + Math.random() * 0.06);
                const platformX = Math.random() * (canvas.width - platformWidth); // X位置をランダムに維持

                // 黄金比に基づくY位置を割り当てる (利用可能な位置が足りない場合はランダムに)
                const platformY = uniqueYPositions[i % uniqueYPositions.length] || (canvas.height * (0.3 + i * 0.4) + (Math.random() - 0.5) * 50); // フォールバックも調整

                platforms.push(new Platform(platformX, platformY, platformWidth, platformHeight));
            }
        }

        // アニメーションループ
        function animate() {
            // 背景を黒の微妙なグラデーションで塗りつぶし、軌跡効果を作成
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            // 軌跡が黒っぽく見えないように、透明度をさらに上げる
            // 透明度をさらに上げて、軌跡の「濃さ」を減らす
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.0005)'); /* 透明度を0.0005に維持 */
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.0015)'); /* 透明度を0.0015に維持 */
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 各プラットフォームを描画 (ただし、Platformクラスのdrawメソッドは透明なので見えない)
            platforms.forEach(platform => {
                platform.draw();
            });

            // 各球体を更新して描画
            for (let i = 0; i < spheres.length; i++) {
                spheres[i].update();
                spheres[i].draw();
            }

            requestAnimationFrame(animate); // 次のフレームを要求
        }

        // ウィンドウのリサイズイベントハンドラ
        function onWindowResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            spheres.length = 0; // 球体をクリア
            platforms.length = 0; // プラットフォームをクリア
            initSimulation(); // シミュレーションを再初期化
        }

        // 初期化とアニメーションの開始
        window.onload = function () {
            initSimulation();
            animate();
        };

        // クリックイベントリスナーを追加
        canvas.addEventListener('click', () => {
            spheres.forEach(sphere => {
                // 各球体にランダムな上向きの力と横方向の力を加える
                // クリック時の力を質量に反比例させる
                const effectiveClickImpulseStrength = clickImpulseStrength * (maxSphereMass / sphere.mass);
                sphere.vy = -effectiveClickImpulseStrength * (0.5 + Math.random());
                sphere.vx = (Math.random() - 0.5) * effectiveClickImpulseStrength; // 横方向の力を強化
            });
        });

        window.addEventListener('resize', onWindowResize);
    </script>
</body>
</html>
